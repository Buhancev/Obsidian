2023-01-3122:49
Tags: #Java #SpringFramework #SpringBoot #SpringSecurity #OAuth2

__
# Знакомство с OAuth 2

Для начала реализуем несколько конечных точек, которые будут управлять списком ингредиентов:
```java
@RestController
@RequestMapping(path="/api/ingredients", produces="application/json")
@CrossOrigin(origins="http://localhost:8080")
public class IngredientController {
	private IngredientRepository ingredientRepo;

	@Autowired
	public IngredientController(IngredientRepository ingredientRepo) {
		this.ingredientRepo = ingredientRepo;
	}

	@GetMapping
	public Iterable<Ingredient> allIngredients() {
		return ingredientRepo.findAll();
	}

	@PostMapping
	@ResponseStatus(HttpStatus.CREATED)
	public Ingredient saveIngredient(@RequestBody Ingredient ingredient) {
		return ingredientRepo.save(ingredient);
	}

	@DeleteMapping("/{id}")
	@ResponseStatus(HttpStatus.NO_CONTENT)
	public Ingredient saveIngredient(@PathVariable("id") String ingredientId) {
		return ingredientRepo.deleteById(ingredientId);
	}
}
```

Сейчас наши конечные точки абсолютны открыты. Их может использовать ЛЮБОЙ. Нужно это исправить.

Один из вариантов - использовать для защиты конечных точек */ingredients* аутентификацию HTTP Basic. Это можно сделать добавив аннотацию **@PreAuthorize** к методам-обработчикам:
```java
	@PostMapping
	@PreAuthorize("#{hasRole('ADMIN')}")
	@ResponseStatus(HttpStatus.CREATED)
	public Ingredient saveIngredient(@RequestBody Ingredient ingredient) {
		return ingredientRepo.save(ingredient);
	}

	@DeleteMapping("/{id}")
	@PreAuthorize("#{hasRole('ADMIN')}")
	@ResponseStatus(HttpStatus.NO_CONTENT)
	public Ingredient saveIngredient(@PathVariable("id") String ingredientId) {
		return ingredientRepo.deleteById(ingredientId);
	}
```

или определив настройки в конфигурации безопастности:
```java
@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
			.antMatchers(HttpMethod.POST, "/ingredients").hasRole("ADMIN")
			.antMatchers(HttpMerhod.DELETE, "/ingredients/**").hasRole("ADMIN")
		...
		;
}
```

![[Pasted image 20230131230116.png]]

HTTP Basic, конечно, защитит API, но эта защита будет уж слишком *простенькой*. Она требует, чтобы клиент и API использовали общие учетные данные пользователя. Более того, HTTP Basic шифрует учетные данные в заголовке запроса с помощью алгоритма Base64, и если хакер перехватит запрос, он легко расшифрует учетные данные...

![[Pasted image 20230131230455.png]]
Примерно так работает OAuth2. Клиент запрашивает токен, который будет использоваться для взаимодействия с API. В любой момент срок токена может истечь или он может быть отознан без смены пароля пользователем. В таких случаях клиент просто запрашивает новый токен доступа.

OAuth2 - очень богатая спецификация безопастности, поддерживающая множество способов её использования. Процесс, изображенный на картинке, называется **предоставлением кода авторизации.** 

В числе других процессов, поддерживаемых спецификацией OAuth2, можно назвать:
- **неявное предоставление разрешений** - по аналогии с предоставление кода авторизации, неявное предоставление разрешений переадресует браузер на сервер авторизации для получения согласия пользователя. Но при обратной переадресации вместо кода авторизации в запрос неявно подставляется токен. Изначальнор этот процесс разрабатывался для клиентов JS, работающих в браузере, и в настоящее время не рекомендуется к использованию; вместо него следует использовать процесс предоставления кода авторизации;
- **предоставление учетных данных (пароля) пользователя** - этот процесс не предусматривает переадресации и вообще может не использовать веб-браузер. Вместо этого клиентское приложение получает данные непосредственно от пользователя и обменивает их на токен доступа. Этот процесс выглядит подходящим для клиентов, не основанных на веб-браузере, однако многие современные приложения предпочитают просить пользователя перейти на веб-сайт в своей браузере и пройти процесс предоставления кода авторизации, чтобы избежать необходимости получать и обрабатывать данные пользователя;
- **предоставление учетных данные клиента** - процесс похож на предоставление учетных данных пользователя, только вместо учетных данных пользователя клиент посылает серверу авторизации свои собственные учетные данные. Однако токен, предоставляемый в ответ, ползволяет выполнить лишь ограниченный круг операций, не связанный с пользователем, и не может применяться для выполнения действий от имени пользователя.


Далее мы будем использовать процесс **предоставления кода авторизации**, чтобы получить токен доступа JSON Web Token (JWT). Для этого нам потребуется:
- **сервер авторизации** - задача сервера заключается в том, чтобы получить от пользователя разрешение, позволяющее клиентскому приложению выступать от его именит. Если пользователь даст разрешение, то сервер авторизации предоставит токен доступа клиентскому приложению, который оно сможет использовать для доступа к API.
- **сервер ресурсов** - это просто другое название API, защищенного с помощью OAuth2, однако в дальнейшем обсуждении мы будем разделять эти два понятия. Сервер ресурсов ограничивает доступ к своим ресурсам, если запрос не предоставляет доступ к действильному токену с необходимым набором разрешений. (Наш сервер ресурсов Taco Cloud API)
- **клиентское приложение** - это приложение, использующее API, для доступа к которому требуется разрешение. Мы напишем простое приложение администратора для Taco Cloud, которое позволит добавлять новые ингредиенты.
- **пользователь** - человек, использующий клиентское приложение и дающий ему разрешение на доступ к API сервера ресурсов от своего имени.
__
### Zero-Links
- [[Безопасность REST API]]

__
### Links
- [[Создание сервера авторизации]]
- [[Защита API с помощью сервера ресурсов]]

