2022-10-1115:40
Tags: #

__
#

__
### Zero-Links
- 

__
### Links
- 

2022-10-0417:01
Tags: #Java #JavaCoreAdvanced #StreamAPI 

__
# Интерфейс Collector
Интерфейс Collector состоит из наборов методов, служащих габлонами для реализации конкретных операций свертки(коллекторов).

## Описание интерфейса Collector
```java
public interface Collector<T, A, R>{
	Supplier<A> supplier();
	BiConsumer<A, T> accumulator();
	Function<A, R> finisher();
	BinaryOperator<A> combiner();
	Set<Charasteristics> characterisctics;
}
```
- T - обобщенный типа собираемых элементов потока данных
- A - типа накопителя, то есть объекта, в котором будет накапливаться частичный результат во время процесса сбора данных
- R - тип объекта - результата операции collect (обычно, хотя и не всегда, коллекция)

Например, можно реализовать класс ToListCollector(T), собирающий все элементы потока Stream(T) в объект List(T), со следующей сигнатурой
```java
public class ToListCollector<T> implements Collector<T, List<T>, List<T>>
```
где используемый в процессе накопления объект станет и итоговым результатом процесса сбора данных

## Разбираемся с объявленными в интерфейсе Collector методами
Первые четыре метода возвращают функцию, предназначенную для вызова методом collect, а пятый, characteristics, возвращает набор характеристик, служащих в качестве подсказок методу collect относительно допустимых при операции свертки оптимизаций(например, распараллеливания)

### Создаем новый контейнер для результата: метод supplier
Метод *supplier* должен возвращать объект типа Supplier - функцию без параметров, создающую при вызове экземпляр пустого накопителя для использования в процессе сбора данных. 

Разумеется, для коллектора, возвращающего в качестве результата сам накопитель например ToListCollector, этот пустой накопитель является результатом процесса сбора данных в случае пустого потока. В нашем ToListCollector метод supplier будет возвращать пустой объект List
```java
public Supplier<List<T>> supplier(){
	return () -> new ArrayList<T>()
}
```
Можно воспользоваться и ссылкой на конструктор
```java
public Supplier<List<T>> supplier(){
	return ArrayList::new;
}
```

### Добавление элемента в контейнер для результата: метод accumulator
Метод accumulator возвращает функцию, осуществляющую операцию свертки. При обходе n-го элемента потока данных эта функция применяется с двумя аргументами
- накопителем (результатом свертки предыдщухи n - 1 элементов потока)
- самим n-м элементом потока
Функция возвращает void, поскольку меняет накопитель "на месте", то есть она меняет его внутреннее состояние, отражая тем самым результат обработки очередного элемента.

В случае с ToListCollector данной функции нужно просто добавить текущий элемент в список, содержащий уже обработанный элементы
```java
public BiConsumer<List<T>, T> accumulator(){
	return (list, item) -> list.add(item);
}
```
Для лакончиности можно воспользоваться ссылкой на метод
```java
public BiConsumer<List<T>, T> accumulator(){
	return List::add;
}
```

### Применяем к контейнеру итоговое преобразование для получения результата: метод finisher
Метод finisher должен возвращать функцию, вызываемую в конце процесса накопления, по завершении прохода по потоку данных для преобразования объекта накопителя в конечный результат всей операции сбора данных. 

Зачастую, как и в случае ToListCollector, объект-накопитель совпадает с ожидаемым конечным результатом. Вследствии этой необходимости выполнять какое-либо преобразование нет, так что метод finisher должен возвращать функцию identity
```java
public Function<List<T>, List<T>> finisher(){
	return Function.identity();
}
```


Описанных трех методов достаточно для выполнения последовательной свертки потока данных, осуществляемой, по крайне мере с точки зрения логики работы, так, как показано на рисунке ниже. На практике, реализация несколько более сложна по причине отложенной природы потоков данных, из-за которой может потребоваться конвейер других, выполняемых до collect, промежуточных операций, а также из-за наличия возможности(хотя бы теоретической) выполнения свертки в паралелльном режиме.

### Объединение двух контейнеров для результатов: метод combiner
Метод, последний их четырех, возвращающих используемую операцией свертки функцию, определяет, каким образом объединяются накопители, полученные в результате параллельной обработки частей потока данных. 

В случае коллектора toList реализация метода проста: список, содержащий собранные из второй части потока элементы, добавляются в конец списка, полученного при обходе первой части
```java
public BinaryOperator<List<T>> combiner(){
	return (list1, list2) -> {
		list1.addAll(list2);
		return list1;
	}
}
```
Благодарю четвортому методу появляется возможность паралелльной свертки потока данных. При этом используется фреймворк ветвления-объединения, появившийся в Java 7, а также абстракция Spliterator.
![[Логические шаги процесса последовательной свертки.png]]
Процесс выполнения
- Исходный поток данных рекурсивно разбивается на подпотоки, пока условие разбиения не становится ложным(паралелльная обработка часто выполняется медленее, чем последовательная, при слишком маленьких еденицах работы; кроме того, нет смысла генерировать число паралелльных задач, которые бы превышало количество ядер процессора)
- На этом этапе все подпотоки обрабатываются паралелльно, каждый - с помощью последовательного алгоритма свертки (на рис 6.7)
- Наконец, все эти частичные результаты объединения с помощью функции, возвращаемой методом combiner коллектора. Это делается путем объединения результатов, соответсвующих каждому подпотоку, возникшему в результате разбиения исходного потока
![[Распаралелливание процесса свертки с помощью метода combiner.png]]

### Метод characteristics
Возвращает неизменяемой набор типа Characteristics, который определяет поведение коллектора - предоставляет "подсказки", можно ли выполнять свертку параллельно и какие оптимизации допустимы. Charateristics - перечесляемый тип:
- UNORDERED - порядок обхода и накопления элементов потока не влияет на результат свертки
- CONCURRENT - функцию accumulator можно вызывать параллельно из нескольких потоков выполнения, и, следовательно, этот коллектор может производить параллельную свертку данных. Если коллектор не помечен как UNORDERED, то он может выполнять параллельную свертку только при работе с неупорядоченным источником данных.
- IDENTITY_FINISH - указывает на то, что метод finisher можно не вызывать, так как функция возвращает объект накопитель. То есть, A накопитель можно без проверки привести к типу результата R.

Разрабатываемый для примера ToListCollector имеет свойство IDENTITY_FINISH, поскольку использует для накопления результатов объект List, который представляет из себя конечный результат. Но не UNORDERE, так как при обработке упорядоченного потока данных необходимо, чтобы порядок сохранялся. Наконец, он CONCURRENT, но в соответсвии с тем что сказано выше, обрабатывать поток данных параллельно он может только в случае, если источник потока данных не упорядочен.

## Собираем ToListCollector()
```java
import java.util.*;  
import java.util.function.*;  
import java.util.stream.Collector;  
import static java.util.stream.Collector.Characteristics.*;  
  
public class ToListCollector<T> implements Collector<T, List<T>, List<T>> {  
      
    @Override  
    //создаем основной пункт для операции сбора данных  
    public Supplier<List<T>> supplier() {  
        return ArrayList::new;  
        //тк накопитель является результатом в случае пустого потока, возвращает пустой List  
    }  
  
    @Override  
    //добавляет обработанный элемент в накопитель (на месте)  
    public BiConsumer<List<T>, T> accumulator() {  
        return List::add;  
        /*  
        Метод accumulator возвращает функцию, осуществляющую операцию свертки.        При обходе n-го элемента потока данных эта функция применяется с двумя аргументами        - накопителем (результатом свертки предыдщухи n - 1 элементов потока)        - самим n-м элементом потока        Функция возвращает void, поскольку меняет накопитель "на месте",        то есть она меняет его внутреннее состояние,        отражая тем самым результат обработки очередного элемента.         */    }  
  
    @Override  
    //тождественная функция  
    public Function<List<T>, List<T>> finisher() {  
        return Function.identity(); //возвращаем накопитель  
    }  
  
    @Override  
    //модифицирует первый накопитель, объединяя его с содержимым второго  
    public BinaryOperator<List<T>> combiner() {  
        return (list1, list2) -> {  
            list1.addAll(list2);  
            return list1;//возвращаем модифицированный накопитель  
        };  
    }  
  
    @Override  
    public Set<Characteristics> characteristics() {  
        return Collections.unmodifiableSet(EnumSet.of(  
                //помечаем коллектор как  
                IDENTITY_FINISH, CONCURRENT));  
    }  
}
```
Эта реализация не идентичена возвращаемой методом Collectors.toList(), но отличия лишь в мелких оптимизациях, связанных в основном в том, что Java коллектор использует метод Collectors.emptyList() в тех случаях, когда нужно вернуть пустой список.

Наш ToListCollector можно использовать в старых примерах
```java
List<Dish> dishes = menuStream.collect(new ToListCollector<Dish>());
```
Еще одно отличие в том, что toList() - фабричный метод, а для создания экземпляра нашего ToListCollector необходимо использовать new.


__
### Zero-Links
- [[Главное о коллекторах]]

__
### Links
- [[Нестандартный сбор данных без реализации интерфейса Collector]]
- [[Собственный коллектор]]

