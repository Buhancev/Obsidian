2023-02-2000:00
Tags: #Java #SpringFramework #SpringBoot #Reactor

__
# Основы реактивного программирования Spring Reactor

Реактивное программирование - парадигма, альтернатива императивному программированию. Появлиась, потому что реактивное программирование устраняет ограничения, свойственные императивному программированию. Поняв эти ограничения, мы будем лучше понимать преимущества реактивной модели.

Спецификацию Reactive Stream можно свести к четырем определениям интерфейсов:
- **Publisher**
- **Subscriber** 
- **Subscription**
- **Processor**

##  **Publisher**
Создает данные и отправляет их подписчику **Subscriber**.

Интерфейс издателя объявляет единственный метод *subscribe()*, с помощью которого подписчик *Subscriber* может подписаться на события издания:
```java
public interface Publisher<T> {
	void subscribe(Subscriber<? super T> subscriber);
}
```

## **Subscriber**
После оформления подписки подписчик **Subscriber** может получать события от издателя. События отправляются через методы в интерфейсе подписчика:
```java
public interface Subscriber<T> {
	void onSubscribe(Subscrition sub);
	void onNext(T item);
	void onError(Throwable ex);
	void onCompelete();
}
```

Первое событие, которое получит подписчик, - это вызов *onSubscribe()*. Когда издатель вызывает *onSubscribe()*, он передает объект *Subscription* подписчику. Именно через **Subscription** подписчик *Subscribe* может управлять своей подпиской:
```java
public interface Subscription {
	void request(long n);
	void cancel();
}
```
Подписчик *Subscriber* может вызывать **request()**, чтобы запросить отправку данных, или **cancel()**, чтобы отменить подписку.

При вызове **request()** подписчик передает **long, обозначайющий количество элементов данных, которое он готов принять**. **Здесь возникает обратное давление**, не позволяющее издателю отправлять больше данных, чем может обработать подписчик. 

После запроса данных подписчиком *Subscriber* они начинают передаваться через поток. 

- Для каждого элемента, опубликованного издателем *Publisher*, будет вызывать метод **onNext()** для доставки данных подписчику *Subscriber*. 
- В случае появления какой-либо ошибки вызывается **onError()**. 
- Если у издателя *Publisher* закончились данные и он не собирается производить новые данные, он вызывает метод **onComplete**, чтобы сообщить подписчику о завершении работы.

## **Processor**
Представляет комбинацию подписчика *Subscriber* и издателя *Publisher*:
```java
public interface Processor<T, R>
	extends Subscriber<T>, Publisher<R> {};
```
Он может получаться и обрабатывать данные **как Subscriber**, а может сметь ореинтацию и будет действовать **как издатель Publisher**, чтобы публиковать новые данные для своих подписчиков.

Спецификация **Reactive Steams** очень проста. Она позволяет легко создавать конвейеры обработки данных, в которых издатели перекачивают данные через ноль или более процессоров и далее к конечному подписчику.

Однако интерфейсы **Rective Stream не позволяют составлять такие конвейеры фунциональным способом**. По этой причины был создан проект **Project Reactor** - реализация спецификации *Reactive Streams*, предоставляющая функциональный API для создания реактивных потоков.

__
### Zero-Links
- [[Введение в Reactor]]

__
### Links
- 

