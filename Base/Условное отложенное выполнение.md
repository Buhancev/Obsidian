2022-10-2521:29
Tags: #Java #JavaCoreAdvanced #DesignPatterns

__
# Условное отложенное выполнение

Операторы управления потоком выполнения часто декорируются внутри кода бизнес-логики. В числе типичных сценариев - проверка на безопасность и журналирование.

Рассмотри код, в котором используется встроенный класс Logger языка Java
```java
if(logger.isLoggable(Log.FINER)) {
	logger.finer("Problem:" + generateDiagnostic());
}
```
Что с этим кодом не так?
- коду клиента приходится узнавать состояние журналирующего объекта (поддерживаемый им уровень журналирования) через метод isLoggable
- какой смысл в запросе состояния журналирующего объекта перед журналирование каждого сообщения? Это только загромождает код

Лучше использовать метод log, внутри которого перед журналированием сообщения проверяется, правильный ли уровень задан для журналирующего объекта
```java
logger.log(Level.FINER, "Problem:" + generateDiagnostic());
```
Это лучше, так как не загромождает код операторами if, а состояние механизма журналирования не делается доступным. К сожаления, в данном коде всё равно есть проблема: сообщения всегда вычисляется, даже если механизм журналирования не приспособлен для передаваемого в качестве аргумента уровня сообщений.

Здесь помогут лямбда-выражения. Необходимо просто отложить формирование сообщения так, чтобы оно генерировалось только при заданном условии (в данном случае при уровне журналирования FINER). Оказывается, что создатели API Java 8 знали об этой проблеме и создали перегруженный вариант log прпнимающий в качестве аргумента Supplier. Сигнатура этого варианта 
```java
public void log(Level level, Supplier<String> msgSupplier)
```
Так что теперь можно написать следующий вызов
```java
logger.log(Level.FINER, () -> "Problem:" + generateDiagnostic());
```
Передаваемое в качестве аргумента лямда-выражение выполняется внутри метода log только при мехнизме журналирования соответствующего уровня. Внутрення реализация метода log примерно такая
```java
public void log(Level level, Supplier<String> msg) {
	if(logger.isLoggable(Level)){
		log(level, msgSupplier.get()); //выполнение лямбда-выражения
	}
}
```
Какой вывод можно сделать? Если в клиентском коде многократно выполняются запросы состояния объекта (например, состояние журналирующего объекта) лишь для того, чтобы вызвать для этого объекта какой-либо метод с аргументами (например, для журналирования сообщения), имеет смысл создать новый метод, который бы вызывал вышеупомянутый метод, передаваемый в виде лямбда-выражения или ссылки на метод, только после ВНУТРЕННЕЙ проверки состояния объекта. При этом повышается удобочитаемость кода и его инкупсулированность, а состояние объекта не будет доступно в клиентском коде.

__
### Zero-Links
- [[Повышение гибкости кода]]

__
### Links
- 

