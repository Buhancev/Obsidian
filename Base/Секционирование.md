2022-10-0416:11
Tags: #Java #JavaCoreAdvanced #StreamAPI 

__
# Секционирование
Секционирование - частный случай группировки, при котором в качестве функции классификации используется предикат, называемый *секционирующей функцией*.

Поскольку секционирующая функция возвращает булево значение, то типа ключа итогового ассоциативного массива группировки должен быть Boolean, а, cледовательно количетсво различных групп не может привышать двух - одна *true* и одна *false*. 

Например, если вы вегетарианец или позвали на обед друга-вегетарианца, то вам может понадобиться разделить блюда в меню на вегетаринские и нет
```java
Map<Boolean, List<Dish>> partitionMenu = 
	menu.stream().collect(
	partitionBy(DIsh::isVegetarian)); //секционирующая функция
```
В результате получим следующия ассоциативный массив
```java
{false=[pork, beef, chicken, prawns, salmon],  
true=[french fries, rice, season fruit, pizza]}
```
Таким образом, для выяснения всех вегетаринских блюд необходимо извлечь из этого ассоциативного массива значение, индексированное ключом true
```java
{false=[pork, beef, chicken, prawns, salmon],  
true=[french fries, rice, season fruit, pizza]}
```
Таким образом, для выяснения всех вегетарианских блюд необходимо извлечь из этого ассоциативного массива значение, индексированное ключом true
```java
List<Dish> vegetarianDishes = partitionedMenu.get(true);
```

Стоит отметить, что тот же результат можно получить путем фильтрации списка, созданного из объекта menu, на основе того же предиката, что применялся для секционирования, с последующим сбором результатов в один список
```java
List<Dish> vegetarianDishes = menu.stream()
	.filter(Dish::isVegetarian)
	.collect(toList());
```
__
### Zero-Links
- [[Группировка]]

__
### Links
- [[Преимущества секционирования]]
- [[Секционирование чисел на простые и составные]]

