2022-09-0815:42
Tags: #

__
# Лямбда-выражения и Функциональные интерфейсы

- В стандартной библиотеке java.util.* есть различный набор интерфейсов, для параметризации поведения.
- Существуют интерфейсы как для ссылочных типов данных, так и для примитивных.
- Из-за упаковки и распаковки примитивных данных, мы теряем в производительности, поэтому стоит правильно использоваться интерфейсы (Например, IntPredicate)


- Несколько примеров функциольных интерфейсов( на самом деле,  их намного больше )
- ![[функциональны интерфейсы.png]]

- Cтоит отметить, что ни один из приведенных выше функциональных интерфейсов не позволяет генерировать исключения. Если нам нужно, чтобы в теле лямбда-выражения генерировалось исключение, то есть два варианта:
--- Описать свой собственный интерфейс, объявляющий проверяемое исключение.
--- Обернуть тело лямбда-выражения в блок try/catch.

```java
//функциональный интерфейс, который выбрасывает исключения

@FunctionalInterface
public interface BufferedReaderProcessor {
	String process(BufferedReader br) throws IOExceprtion;
}

	BufferedReaderProceesor p = (BufferedReader br) -> br.readLine();

/* Но, возможно, мы используем API, которое ожидает на входе функциональный интерфейса вроде Function(T, R), и нет возможности создать собственный. Далее, в StreamAPI будет видно, что он активно использует функциональные интерфейсы из таблицы функциональных интерфейсов. В таком случае исключение можно перехватить так:
*/

	Function<BufferedReader, String> f = 
	(BufferedReader b) -> {
	try {
		return b.readLine();
	}
	catch(IOException e) {
		throw new RuntimeExceprion(e);
	}
}
```

-  Т.к Java  определяет по контексту(целевому типу) какой функциональный интерфейс нужно связать с лямбда-выражение, то он способен определить и подходящую сигнатуру для этого лямбда-выражения, ведь функциональный дискрптор можно узнать по целевому типу. Выгода в том, что можно опустить типа параметров в лямда-выражении
```java
List<Apple> greenApples = 
	filter(inventory,
			apple -> GREEN.equals(apple.getColor())); 
			//у параметра apple не указан явный тип
```

- Повышение удобочистаемости кода еще заметнее с несколькими параметрами
```java
Comparator<Apple> c = 
		//без вывода типов
		(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()); 

Comparator<Apple> c = 
		//c выводом типов
		(a1, a2) -> a1.getWeight().compareTo(a2.getWeight()); 
```
- Cтоит отметить, что удобочитаемость зависит от опеределенного случая. В одиних лучше с выводом типов, в других без вывода типов. Разработчики должны сами выбирать вариант, при котором их код будет казаться понятнее.


### Links
- [[Функциональный интерфейс Predicate]]
- [[Функциональный интерфейс Consumer]]
- [[Функциональный интерфейс Function]]
- [[Проверка типов Лямбда-выражений]]
- [[Лямбда-выражения с захватом переменных]]


__
### Zero-Links
- [[00 Параметризация поведения]]