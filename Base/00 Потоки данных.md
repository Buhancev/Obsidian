2022-09-2111:05
Tags: #Java #JavaCoreAdvanced #StreamAPI 

__
# Потоки данных
Все коллекции Java 8 поддерживают новый метод *stream*, который возвращает поток данных (описание в java.util.stream.Stream)

Поток данных - полученная из источника последовательность элементов, поддерживающая операции обработки данных.
	- *Последовательность элементов* - подобно колеллекции, поток данных обечпечивает интерфейс для упорядоченного набора значений определенного типа. Коллекции, как структуры данных, в основном, решают задачу хранения и доступа к элементам с конкретными нюансами временного или пространственного характера. Потоки данных выражают вычислительные операции (filter, sorted, map). При работе с коллекциями упор делается на данные; а при работе с потоками данных - на их обработке.
	- *Источник* потоки данных поддерживают операции в стиле БД и распространнеые операции над данными из функциональных ЯП, такие filter, map, reduce, find, match, sort. Выполнять потоковые операции можно как последовательно, так и паралелльно.
	Кроме того, у потоковых операций есть две важные хар-ки:
	- *Возможность конвейерной организации* - многие из потоковые операций сами возвращают поток данных, благодарю чему их можно соединить их в цепочкой. Это делает возможным *отложенную* обработку (laziness) и *сокращенное* вычисление (short-circuiting). Конвейер операций можно рассматривать как аналог запроса к источнику данных.
	- *Внутренняя* итерация - в отличии от коллекции, циклы по которым описываются явным образом, с помощью итераторов, потоковые операции производят итерации незаметно для нас:
```java
import static java.util.stream.Collectors.toList;

List<String> theeHighCaloricNames = 
				menu.stream() //создаем конвейер операций
					.filter(dish -> dish.getCallories > 300)//фильтрация
					.map(Dish::getName)//получаем названия блюд
					.limit(3)//выбираем только 3 блюда
					.collect(toList());//сохраняем результаты в другом объекте
2022-10-0220:47
Tags: #

__
#

__
### Zero-Links
- 

__
### Links
- 


System.out.println(threeHighCaloricDishNames);
```
*Источником* данных является список блюд (menu) из которого поток получает *последовательность* элементов. Далее мы применяем к потоку данных ряд операций *обработки* данных: filter, map, limit и collect. Каждая из этих операций, за исключением collect, возвращает поток данных, так что их допускается соеденить, чтобы образовать *конвейер*, который можно рассматривать в качестве запроса к источнику. Наконец, функция collect запускает обработку данных и возвращает результат (эта операция отличается от других тем, что возвращает не поток, а - в данном случае - объект List). До тех пор пока не будет вызван метод *collect*, никакого результата не возвращается и, конечно, не выбирается ни один метод из списка menu. Можно считать, что вызовы методов в цепочке ожидают очереди, пока не будет вызван метод collect. 
![[Фильтация меню с помощью потока данных.png]]

Написанный нами код отличается от пошаговой обработки списка элементов меню.
Используется намного более декларативный стиль описания обработки данных из меню: мы сообщаем, *что* хотели бы получить результат. Мы не реализуем функциональность операций фильтрации(filter), извлечения(map), или усечения(limit), поскольку она уже есть в готовом виде в библиотеке потоков. 
В результате, StreamAPI получает большее количество свободы для принятия решений об оптимизации конвейера. Например, шаги фильтрации, усечения, извлечения можно выполнить за один проход.



### Zero-Links
- [[00 Функциональное программирование с помощью потоков данных]]
- [[00 Фреймворк ветвления-объединения]]

### Links
- [[Работа с потоками данных]]
- [[Числовые потоки данных]]
- [[Создание потоков данных]]
- [[Сбор данных с помощью потоков данных]]
- [[Параллельные потоки данных]]
