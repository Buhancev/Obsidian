2023-02-2820:40
Tags: #Java #SpringFramework #SpringBoot #Reactor #RESTful #WebFlux

__
# Создание реактивных контроллеров

У нас был контроллер, который обрабатывал GET-запрос, который возвращал последние тако:
```java
@RestController
@RequestMapping(path="/api/tacos",
			   produces="application/json")
@CrossOrigin(origins="*")
public class TacoController {
...

	@GetMapping(params="recent")
	public Iterable<Taco> recentTacos() {
		PageRequest page = PageRequest.of(
			0, 12, Sort.by("createdAt").descending()
		);

		return tacoRepo.findAll(page).getContent();
	}

...
}
```
Метод возвращает список последних созданных рецептов тако. В частности, возвращает коллекцию **Iterable** с объектами Taco. 

Это решение прекрасно работает, но Iterable не является реактивным типов. К нему нельзя применить реактивные операции, и фреймворк не может использовать его как реактивны типа для распределения работы между несколькими потоками. А нам хотелось бы, чтобы возвращался **Flux(Taco)**.

Самый простое, но ограниченное решение - переписать **recentTacos()** и преобразовать в нем Iterable в Flux. При этом можно избавиться от объекта *Page* и заменить его операцией **take()** к потому Flux:
```java
@GetMapping(params="recent")
public Flux<Taco> recentTacos() {
	return Flux.fromIterable(tacoRepo.findAll()).take(12);
}
```
Преобразование коллекции в поток дало нам некоторый выигрыш. Но было бы еще лучше, если бы поток Flux возвращался репозиторием, чтобы избежать дополнительного преобразования.

В этом случае **recentTacos()** мог бы выглядеть так:
```java
@GetMapping(params="recent")
public Flux<Taco> recentTacos() {
	return tacoRepo.findAll().take(12);
}
```
Этот код выглядит еще проще! В идеале реактивный контроллер должен быть вершиной стека, включающего другие контроллеры, репозитории, базы данных и любые промежуточные службы.

Пример такого сквозного реактивного стека:
![[Pasted image 20230228205101.png]]
**Такой сквозной стек требует, чтобы репозиторий поддерживал возможность возврата потоков Flux вместо коллекций Iterable.**

Создание реактивных репозиториев будет рассмотрено позже, а пока просто посмотрим, как может выглядеть реактивный репозиторий:
```java
public interface TacoRepository extends ReactiveCrudRepository<Taco, Long> {
}
```
Стоит отметить, что кроме использования Flux вместо Iterable, а также способо получения этого потока Flux порядок определения реактивного конроллера ничем не отличается от определения нереактивного.

Оба они снабжены аннотацией **@RestController** и **@RequestMapping** на уровне класса. Оба имеют методы обработки запросов с аннотациями **@GetMapping** на уровне метода. Фактически вся разница сводится к типу значения, возвращаемого обработчиком.

Стоит отметить, что несмотря на то что метод контроллера получает поток Flux(Taco) из репозитория, он может вернуть его без вызова **subscribe()** - фреймворк сам вызовет его. Это значит, что обработав запрос к конечной точке метод завершится еще до того, как данные будут извлечены из БД!
__
### Zero-Links
- [[Spring WebFlux]]
- [[Введение в Spring WebFlux]]

__
### Links
- [[Возврат одиночных значений WebFlux]]
- [[Работа с типами RxJava]]
- [[Реактивная обработка входных данных]]

