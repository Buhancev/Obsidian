2022-10-1517:36
Tags: #Java #JavaCoreAdvanced #StreamAPI 

__
# Правильное применение параллельных потоков данных

Основная причина ошибок - примение алгоритмов, меняющих какое-либо совместно используемое состояние.

Например, вычисление суммы первых n натуральных чисел с помощью изменения совместно используемого накопителя
```java
public long sideEffectSum(long n) {
	Accumulator accumulator = new Accumulator();
	LongStream.rangeClosed(1, n).forEach(accumulator:add);
	return accumulator.total;
}

public class Accumulator {
	public long total = 0;
	public void add(long value) { total += value; }
}
```
Данный код совершенно безнадежен, поскольку является последовательным. При каждом обращении к total1 будет возникать состояние гонки сигналов. А если попытаться исправить эту ситуация с помощью синхронизации, то потеряется весь параллелизм.

Если преобразовать этот код в параллельный
```java
public long sideEffectSum(long n) {
	Accumulator accumulator = new Accumulator();
	LongStream.rangeClosed(1, n)
		.parallel()
		.forEach(accumulator:add);
	return accumulator.total;
}

public class Accumulator {
	public long total = 0;
	public void add(long value) { total += value; }
}
```
То получим, что при каждом выполнении получаем совершенно различные значения. Причина состоит в конкурентном обращении нескольких потоков выполнения к одному накопителю, и, в частности, выполнении оператора total += value, который, вопреки первому впечатлению не атомарный. 

Источник проблемы - метод вызываемый вунтри блока forEach, в виде изменения состояния объекта, совместно используемого в нескольких потока выполнения. Стоит избегать подобных ситуаций, если не хотим столкнуться с неприятными неожиданностями при использовании параллельных потоков!

__
### Zero-Links
- [[Превращаем последовательный поток данных в параллельный]]
- [[Параллельные потоки данных]]

__
### Links
- 

