2022-10-2520:40
Tags: #Java #JavaCoreAdvanced #StreamAPI 

__
# От императивной обработки данных до потоков
В коде обработки коллекции лучше использовать Stream API вместо стандартных паттернов с итераторами. Почему? StreamAPI позволяет ясно выразить назначение конвейера обработки. Кроме того, возможна неявная оптимизация выполнения потоков.

Следующий императивный код выражает два способа (фильтрация и извлечение), которые часто декорируются совместно, из-за чего программисту приходится сначала разбираться в реализации, прежде чем выяснять, что делает код. Кроме того, при этом усложняется реализация выполнения кода параллельно.
```java
List<String> dishNames = new ArrayList<>();
for(Dish dish : menu) {
	if(dish.getCalories() > 300)
		dish.add(dish.getName());
}
```
Альтернативный вариант с использованием StreamAPI читается как описание формулировки задачи и легко распараллеливается
```java
menu.parallelStream()
	.filter(d -> d.getCalories() > 300)
	.map(Dish::getName)
	.collect(toList());
```
К сожалению, переход от имеративного кода к StreamAPI может оказаться непростой задачей, ведь приходится искать подходящие потоковые операции с учетом операторов управления потоко выполнения, таких как *break, contunue, return*. Хорошая новость, есть утилиты, упрощающие решение и этой задачи - LambdaFicator, https://ieeexplore.ieee.org/document/6606699
__
### Zero-Links
- [[00 Рефакторинг, тестирование и отладка]]

__
### Links
- 

