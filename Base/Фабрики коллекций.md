2022-10-1818:43
Tags: #Java #JavaCoreAdvanced #CollectionAPI 

__
# Фабрики коллекций
Например, нужно сгруппировать имена друзей, отправляющихся в паутешествие
```java
//один из способов
List<String> friends = new ArrayList<>();
friends.add("semen");
friends.add("danila");
friends.add("maxim");
```
Прямо скажем, изрядное количетсво кода ради сохранения всего лишь трех строковых значений. Удобнее будет использовать для написания этого кода фабричный метод Arrays.asList()
```java
List<String> friends = 
	Arrays.asList("semen", "danile", "maxim");
```
При этом создается список ФИКСИРОВАННОГО размера, значения которого можно менять, но нельзя лишь добавлять/удалять. Попытка добавляешься элементов приводит к генерации исключения UnsupportedModificationException, обновление же списка с помощью метода set вполне допустимо
```java
List<String> friends = 
	Arrays.asList("semen", "danile", "maxim");
friends.set(0, "sveta");
friends.add("timur"); //генерирует исключение UnsupportedModificationException
```
Пободное поведение выглядит странно, поскольку в основе этого лежит изменяемый список фиксированного значения.


А что насчет множеств? К сожалению, фабричного метода Arrays.asSet() не существует, так что придется использовать другую уловку, а именно - конструктор HashSet, принимающим в качестве аргумента спискок
```java
Set<String> friends =
	new HashSet<>(Arrays.asList("semen", "danile", "maxim"));
```
Или можно использовать StreamAPI
```java
Set<String> friends =
	Stream.of("semen", "danile", "maxim")
		.collect(Collectors.toSet());
```
Оба этих решения сложно назвать изящными, они требуют выделение памяти под лишние объекты. Отметик также, что в результате мы получает ИЗМЕНЯЕМЫЙ объект Set.


А что насчет ассоциативных массиво? Изящного способа создания маленьких ассоциативных массивов не существует, но не стоит переживать, в Java 9 были добавлены фабричные методы, упрощающие жизнь программиста при создании маленьких списков, множеств и ассоциативных массивов.

### Перегрузка и аргумент переменной длины
Если посмотреть интерфейс List, то можно увидеть перегруженные варианты метода List.of
```java
static <E> List<E> of(E e1, E e2, E e3, E e4)
static <E> List<E> of(E e1, E e2, E e3, E e4, E e5)
```
В чем же смысл, если можно использовать один метод в которой бы применялась сигнатура аргумента переменной длины для получения произвольного количества элементов
```java
static <E> List<E> of(E... elements)
```
Дело в том, что версия с аргументом переменной длины неявно выделяет память под дополнительный массив, обернутый в список. В итоге пришлось бы тратить ресурсы на выделение доп памяти для массива, его инициализацию и на сборку мусора. А при указании фиксированного числа элементов (до 10) эти накладные расходы отсутсвуют. Но можно создать список и из элементов длины больше чем 10, но в этом случае будет использоваться вышеупомянутая сигнатура с аргументов переменной длины. Аналогичная схема наблюдаеться и для методов Set.of и Map.of
_
### Zero-Links
- [[00 Расширения CollectionAPI]]

__
### Links
- [[Фабрика списков]]
- [[Фабрика множеств]]
- [[Фабрика ассоциативных массивов]]
- [[Работа со списками и множествами]]]
- [[Работа с ассоциативными массивами]]

