2023-02-1422:55
Tags: #Java #SpringFramework #SpringBoot #SpringIntegraton

__
# Каналы сообщений

Каналы - средства, с помощью которых сообщения перемещаются по конвейеру интеграции.
Каналы соединяют вместе все остальные части Spring Integration.
![[Pasted image 20230214225702.png]]

Spring Integration предоставляет несколько реализаций каналов, в том числе:
- **PublishSubscribeChannel** - сообщения, опубликованные в *PublishSubscribeChannel*, передаются одному или нескольким получателям. Если получателей несколько, то все они получат сообщение;
- **QueueChannel** - сообщения, опубликованные в *QueueChannel*, хранятся в очереди, пока не будет извлечены получателем в порядке их поступлеления (FIFO). Если получателей несколько, то только один из них получат сообщение;
- **PriorityChannel** - действует аналогично *QueueChannel*, но сообщения извлекаются получателем не в порядке поступления, а с учетом приоритетов, указанных в заголовках **priority** сообщений;
- **RenderzvousChannel** - действует аналогично *QueueChannel*, за исключением того, что попытка отправителя послать следующее сообщение блокируется, пока получатель не извлечет предыдущее сообщение, что позволяет эффективно синхронизировать работу отправителя и получателя;
- **DirectChannel** - действует аналогично *PublishSubscribeChannel*, но отправляет сообщение одному получателю, вызывая его в том же потоке выполнения, в котором действует отправитетель. Это позволяет передавать транзакции через весь канал;
- **ExecutorChannel** - действует аналогично *DirectChannel*, но отправка сообщения производит через **TaskExecutor** в отдельном потоке выполнения. Каналы этого типа не поддерживают транзакции, охватывающие каналы целиком;
- **FluxMessageChannel** - канал сообщений **Reactive Stream Publisher** на основе **Flux Project Reactor**.

В обоих стилях конфигурации - Java и Java DSL - входные каналы создаются автоматчиески и **по умолчанию DirectChannel**. Но если решим применить другую реализацию, то нужно создать bean-компонент и сослаться на него в потоке интеграции.

Например, чтобы использовать канал **PublishSubscribeChannel**, нужно объвить следующий метод с аннотацией @Bean:
```java
@Bean
public MessageChannel orderChannel() {
	return new PublishSubscribeChannel();
}
```

Затем следует сослаться на этот канал по имени в определении потока интеграции. 

Например, если канал используется компонентов активатора службы, то сослаться можно в атрибуте **inputChannel** аннотации **@ServiceActivator**:
```java
@ServiceActivator(inputChannel="orderChannel")
```

Или если используется конфигурация в стиле Java DSL, то сослаться на него можно в вызове **channel()**:
```java
@Bean
public IntegrationFlow orderFlow() {
	return IntegrationFlows
		...

		.channel("orderChannel")

		...

		.get();
}
```

Следует отметить, что при использовании **QueueChannel** получатели должны быть настроены на опрос очереди.

Например, решили создать **QueueChannel**:
```java
@Bean
public MessageChannel orderChannel() {
	return new QueueChannel();
}
```
Тогда мы должны также гарантироват, что получатель будет переодически опрашивать канал на наличие сообщений. В случае активатора службы аннотация **@ServiceActivator** может выглядеть так:
```java
@ServiceActivator(inputChannel="orderChannel",
				 poller=@Poller(fixedRate="1000")) 
```
В этом примере активатор службы опрашивает канал **orderChannel раз в 1 секунду**.

__
### Zero-Links
- [[Ландшафт Spring Integration]]

__
### Links
- 

