2022-10-1521:38
Tags: #Java #JavaCoreAdvanced #Fork/Join-Framework 

__
# Рекомендуемые практики применения фреймворка ветвления-объединения
Насколько легко использовать фреймворк Fork-Join, настолько же легко его использовать неправильно.

- Вызов для задачи метода join блокирует вызывающую программу вплодь до момента готовности результата. Поэтому вызывать его необходимо после начала вычисления обоих подзадач. В противном случае алгоритм превратится в более медленную и запутанную версию первоначального последовательного алгоритма, ведь каждая задача, прежде чем начать работать, должна будет дождаться завершения предыдущей.
- Метод invoke класса ForkJoinPool не следует использовать внутри RecursiveTask. Вместо него нужно вызывать непосредственно методы compute и fork; invoke должен использоваться лишь в последовательном коде для запуска параллельных вычислений.
- Чтобы запланировать выполнение подзадачи в ForkJoinPool, следует вызывать для неё метод fork. Может показаться логичным вызывать его как для правой, так и для левой подхадачи, но эффективнее вызвать её для одной из них метод compute. Это позволит переиспользовать один и тот же потока выполнения для одной из двух подзадач, чтобы избежать затрат на выделение пулом дополнительных ресурсов.
- Отладка кода для параллельных вычислений, использующих фреймворк Fork-Join может оказаться непростой задачей. В частности, для разработчкиво обычным делом является просмотр стека трассы вызывов в своем любимом IDE, чтобы обнаружить источник проблемы. Но при вычислении Fork-Join этот способ не сработает, ведь вызов метода compute происходит в потоке выполнения, отличном от вызвашего fork кода.
- Стоит учитывать, что параллельные вычисления не обязятельно быстрее, об этом говорилось ранее в параллельных потока данных.

Стоит правильно выбирать критерий, определяющий, нужно ли далее разбивать задачу на подзадачу, или её размеры уже достаточно малы, для последовательного выполнения. [[Перехват работы]]
__
### Zero-Links
- [[00 Фреймворк ветвления-объединения]]

__
### Links
- [[Перехват работы]]

