2022-10-1520:48
Tags: #Java #JavaCoreBase #Fork/Join-Framework 

__
# Работа с классом RecursiveTask

Для отправки значений в этот пул необходимо создать подкласс класса RecursiveTask(R), где R - тип возвращаемого распараллеленной задачей (и всеми её поздачами) результата, или RecursiveAction, если задача ничего не позвращает (обновляет данные в других, не локальных структурах).

Для описания класса RecursiveTask достаточно реализовать его единственный абстрактный метод 
```java
protected abstract R compute();
```
Этот метод задает как логику разбиения задачи на подзадачи, так и получения результата отдельной задачи в случае, когда дальнейшее разбиение невозможно или не имеет смысла. Поэтому реализация данного метода часто напоминает следующий псевдокод
```java
if(задача достаточно мала, или её нельзя далее делить) {
	произвести необходимые для задачи вычисления последовательным образом
}
else {
	разбить задачу на две подзадачи
	вызвать текущий метод рекурсивно, возможно далее разбивая подзадачи
	ожидать результата всех подзадач
	объединить результаты выполнения подзадача
}
```
Нет никакого точного критерия, как следует делить конкретную задачу, есть лишь различные эвристические алгоритмы, облегчающие принятие подобного решения.
Можно сказать что это алгоритм "Разделяй и властвуй". Ниже примерный вид этого алгоритма.
![[процесс ветвления-объединения.png]]

Для демонстрации практического примера использования фреймворка Fork-Join на основе наших предыдущих примеров попробуем с его помощью вычислить сумму диапазона чисел ( в данном случае представленного в виде массива целых чисел long[]).

Как уже говорилось ранее, необходимо создать реализацию класса RecursiveTask.
```java
public class ForkJoinSumCalculator
	extends java.util.concurrent.RecursiveTask<Long> {
	private final long[] numbers; //массив суммируемых чисел
	private final int start;
	private final int end;
	//пороговое значения размера для разбиения на подзадачи
	public static final long THRESHOLD; 
	//общедоступный конструктор для создания основной задачи
	public ForkJoinSumCalculator(long[] numbers) {
		this(numbers, 0, numbers.lenght);
	}
	//приватный конструктор для создания подзадач основной задачи
	private ForkJoinSumCalculator(long[] numbers, int start, int end) {
		this.numbers = numbers;
		this.start = start;
		this.end = end;
	}
	@Override
	protected Long compute() {
		//размер суммируемого данной подзадачей массива
		int lenght = end - start;
		//если размер меньше или равен пороговому значению, вычисляем последовательно результат подзадачи
		if(lenght <= THRESHOLD) {
			return computeSequentially();
		}
		//создаем подзадачу для первой половины массива
		ForkJoinSumCalculator leftTask =
			new ForkJoinSumCalculator(numbers, start + lenght/2);
		//асинхронно выполняет только что созданную подзадачу используя еще один поток выполнения из ForkJoinPool
		leftTask.fork();
		//создаем подзадачу для второй половины массива
		ForkJoinSumCalculator rightTask =
			new ForkJoinSumCalculator(numbers, start + lenght/2; end);
		//выполняем вторую задачу синхронно, обеспечивая возможность дальнейшего рекурсивного разбиения
		Long rightResult = rightTask.compute();
		//читаем результат выполнения первой подзадачи, при необходимости ожидая завершения её работы
		Long leftResult = leftTask.join();
		//объединяем результаты двух подзадач
		return leftResult + rightResult;
	}
	//простой последовательный алгоритм вычисления для задач, размер который меньше порогового значения
	private Long computeSequentially() {
		long sum = 0;
		for(int i = start; i < end; i++) {
			sum += numbers[i];
		}
		return sum;
	}
}
```
Теперь написание метода для параллельного суммирования первых n натуральных чисел становится тривильной задачей
```java
public static long forkJoingSum(long n) {
	long[] numbers = LongStream.rangeClosed(1, n).toArray();
	ForkJoinTask<Long> task = new ForkJoinSumCalculator(numbers);
//создаем ForkJoinPool и передаем задачу в его метод invoke
	return new ForkJoinPoll().invoke(task);
}
```
Отметим, что создавать более одного объекта ForkJoinPool не имеет смысла. Поэтому обычно создают только один экземпляр данного класса и хранят ссылку на него в статическом поле, превращая его, таким образом, в объект-одиночку, благодаря чему его можно переиспользовать в любой части вашего программного обеспечения. Для его создания мы здесь используем конструктор по умолчанию без аргументов, который сам определяем количество доступных ядер в данный момент(процессоров).
## Выполнение задачи ForkJoinSumCalculator
![[алгоритм ветвления-объединения.png]]
Передаваемая ForkJoinPool задача ForkJoinSumCalculator выполняется одним из его потоков выполнения, который вызывает метод compute этой задачи. В этом методе проверяется достаточно ли мала задача; если нет, то массив разбивается на пополам, а половины распределяются по двум объектам ForkJoinSumCalculator для дальнейшего выполнения с помощью пула. В результате процесс повторяется рекурсивно до тех пор пока не перестанет выполнять условие разбиения. После этого результаты всех подзадач вычисляются последовательно и производится обход созданного бинарного дерева задач - от листьев к корню. Далее частичные результаты объединяются в один.
__
### Zero-Links
- [[00 Фреймворк ветвления-объединения]]

__
### Links
- 

