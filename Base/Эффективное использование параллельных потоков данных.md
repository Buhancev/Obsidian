2022-10-1517:53
Tags: #Java #JavaCoreAdvanced #StreamAPI 

__
# Эффективное использование параллельных потоков данных
Невозможно дать количественные критерии того, когда следует использовать параллельные потоки данных. Тем не менее можно по крайне мере дать некоторые качественные советы, полезные для принятия решения о целесообразности использования параллельного потока данных в конкретной ситуации.
- Если сомневаетесь - измеряйте. Стоит проверять на производительность и на правильность результатов выполнения.
- Остерегайтесь упакови. Автоматические операции упаковки и распаковки могут значительно снизить производительность, поэтому нужно использовать отдельные версии поток для простых типов данных.
- Некоторые операции работают хуже при параллельных потоках данных, чем на последовательных. В частности, значительных ресурсов требуют такие операции, как limit и findFirst, зависящие от порядка элементов.
	Например, оперция findAny будет работать быстрее, чем findFirst, поскольку не обязана анализировать элементы в порядке обнаружения. Упорядоченный поток данных всегда можно преобразовать в неупорядоченный, вызвав метод unordered. Например, с целью получения N элементов потока, причем не обязательно *первых* N элементов. Эффективнее будет вызвать метод limit для неупорядоченного параллельного потока, а не потока с заданным порядком обноружения.
- Оцените общие вычислительные затраты. N - число обрабатываемых элементов, а Q - приблизительные затраты на обработку одного элемента в рамках конвейера потока, то сумарные затраты Q * N. Чем выше Q, тем больше шансов на хорошую производительность при параллельном использовании потока данных.
- При небольших объемах данных выбирать параллельлный потока почти никогда не имеет смысла.
- Необходимо учитывать насколько хорошо разбивается на порции структура, лежащая в основе потока. Например, ArrayList разбивается эффективнее, чем LinkedList, поскольку первый можно разбить на порции без его обхода, в отличии от второго. Кроме того, легко разбиваются на порции специализированные версии потоков для простых данных, созданные с помощью фабричного метода range. Наконец, можно управлять нюансами разбиения с помощью создания собственного сплиттера
-  Характеристики потока данных, а также модификация этих характеристик промежуточными операциями на протяжении конвейера могут менять производительность процесса разбиения. Например, поток с характеристикой SIZED можно разбить на две равные части, которые более эффективно — обработать параллельно, но при фильтрации может оказаться отброшено непредсказуемое число элементов, вследствие чего размер потока окажется неизвестным.
- Стоит учесть, насколько велики затраты на шаг объединения в заверщающей операции(например, метод combiner коллектора). Если этот шаг дорогостоящий, то затраты промежуточных результатов отдельных потоков могут перевесить выгоды параллельного потока в смысле производительности

![[пригодность различных источников потоков данных к разбиению.png]]

__
### Zero-Links
- [[Параллельные потоки данных]]

__
### Links
- 

