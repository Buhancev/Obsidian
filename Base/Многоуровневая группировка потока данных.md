2022-10-0412:19
Tags: #Java #JavaCoreAdvanced #StreamAPI 

__
# Многоуровневая группировка потока данных
 До сих пор использовался один критерий группировки блюд в меню, например, по их типу или числу калорий, но что, если нужно одновременно несколько критерием? - сила операции группировки - в эффективности агрегирования элементов.

Двумя элементами фабричного метода Collectors.groupingBy можно воспользоваться и для группировки второго уровня. Для этого можно передать внешнему методу groupingBy второй внутренний groupingBy, задав в нем критерий второго уровня для классификации элементов потока
```java
Map<Dish.getType, Map<CaloricLevel, List<Dish>>> dishesByCaloricLevel = menu.stream()
	.collect(groupingBy(Dish::getType,
	//классификация второго уровня
		groupingBy(dish -> {
			if(dish.getCalories() <= 400) return CaloricLevel.DIET;
			else if(dish.getCalories() <=700) return CaloricLevel.NORMAL;
			else return CaloricLevel.FAT;
			})
		) 
	);
```
Результат этой двухуровней группировки представляет собой следующий ассоциавтивный массив
```java
{MEAT={DIET=[chicken], NORMAL=[beef], FAT=[pork]},  
FISH={DIET=[prawns], NORMAL=[salmon]},  
OTHER={DIET=[rice, seasonal fruit], NORMAL=[french fries, pizza]}}
```
Здесь ключ внешнего ассоциативного массива (Map) - значение, сгенерированные функцией классификации первого уровня: MEAT, FISH, OTHER. 
Значения этого ассоциативного массива также являются, в свою очередь, ассоциативными массивами, ключи которых - сгенерированные функцей классификации второго уровня: DIET, NORMAL, FAT. Наконецб значения ассоциативных массивов второго уровня: списки (List) элементов потока, для которых функции классификации первого и второго уровня возвращают соответсвующие ключи первого и второго уровня.

Подобную операцию группировки можно обобщить на проивольное число увроней, при этом результатом n-уровневой группировки будет n-уровневый ассоциативный массив, моделирующий n-уровневую дреровидную структуру

![[Эквивалентность ассоциативного массива с n уровнями вложенности и n-мерной таблицыклассификации.png]]

В целом, удобно считать, что groupingBy работает с термином "корзина". Первый groupingBy создает корзиты для всех ключей. А затем уже можно с помощью расположенного далее по конвейеру коллектора собрать элементы потока в каждой из корзин и т.д., вплоть до n-уровневой корзины.
__
### Zero-Links
- [[Группировка]]
- [[Дальнейшие операции со сгруппированными элементами]]

__
### Links
- 

