2022-09-2110:28
Tags: #Java #JavaCoreAdvanced #StreamAPI

__
# Функциональное программирование с помощью потоков данных

Новая возможность JavaAPI, позволяющая декларативно описывать операции над коллекциями данных( писать запрос, а не код импровизированной реализации). Кроме того, потоки данных можно обрабатывать параллельно *явным образом*, без описания какого-либо многопоточного кода! 
Сравним код, возвращающий название низкокаллорийных блюд в меню, отсортированных по числу каллорий - Cначала Java 7, а потом Java 8 с помощью потоков данных. 

```java
Java 7

List<Dish> lowCaloriesDishes = new ArrayList<>();
for(Dish dish : menu) {
	if(dish.getCalories() < 400) {
		lowCaloriesDishes.add(dish); //фильтрация по каллориям
	}
}
//Сортировка блюд с помощью анонимного класса
Collections.sort(lowCaloriesDishes, new Comparator<Dish>() {
	public int compare(Dish dish1, Dish dish2) {
		return Integer.compare(dish1.gelCalories(), 
							   dish2.getCalories());
	}
});

List<String> lowCaloriesDishesName = new ArrayList<>();
for(Dish dish : lowCaloriesDishes) {
	lowCaloriesDishesName.add(dish.getName());
	//обработка отсортированных блюд
}
```
В этом коде используется "мусорная переменная" lowCaloriesDishes. Её единственная роль - одноразовый промежуточный контейнер. В Java 8 эта деталь реализации перемещена в библиотеку, где ей самое место.

```java
Java 8 
import static java.util.Comparator.comparing;
import static java.util.stream.Collections.toList;

List<String> lowCaloriesDishesName = 
					menu.stream()
						//фильтрация
						.filter(d -> d.getCalories() < 400)
						//сортировка
						.sorted(comparing(Dish::getColaries))
						//mapping/извлечение
						.map(Dish::getName)
						.collect(toList);
						//Сохраняем название в списке
```

Чтобы воспользоваться преимуществами многоядерной архитектуры, для параллельного кода достаточно поменять вызов .stream() на .parallelStream()

У данного подхода есть несколько очевидных плюсов:
- Код написанный в *декларативном* стиле: вы указываете, *что* хотели бы получить, а не *как* реализовать операцию ( с помощью операторов управления потоком выполнения, например циклов и условных операторов if ). Как и [[00 Параметризация поведения]] такой подход помогает адаптироваться к изменению требований: можно легко создать дополнительный вариант кода. Другая сторона этого преимущества: отделение модели многопоточного выполнения от самого запроса. Благодаря тому, что описывается только "рецепт" запроса, его можно выполнять последовательно или паралелльно.
- Для выражения сложного конвейра обработки данных несколько стандартных данных соединяют цепочкой (мы соединяли filter, sorted, map и collect). При этом код сохраняется удобочитаемым, а его назначение - понятным. 

Благодаря тому, что такие операции, как filter (а также sorted, map, collect и другие) предоставлены в виде *высокоуровневых стандартных блоков*, не зависящих от конкретной модели выполнения в потоках, их внутренняя реализация может быть как однопоточной, так и - потенциально - максимально поточной в вашей архитектуре!

На практике значит, что не нужно волноваться о потоках или блокировке. StreamAPI всё сделает за нас! 
![[создание конвеера с помощью соединения операций цепочкой в  StreamAPI.png]]

StreamAPI позволяет писать код:
- декларативный - более лаконичный
- удобный для компановки - более гибкий
- параллелизуемый - более производительный

__
### Links
- [[00 Потоки данных]]
- [[Потоки данных и коллекции]]

