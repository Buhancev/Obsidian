2023-01-2918:26
Tags: #Java #SpringFramework #SpringBoot #RESTful 

__
# Изменение данных на сервере

**Почему существует два разных HTTP-метода для изменения ресурсов?**
PUT часто используют для обновления существующих ресурсов. На самом деле это синематическая противолополжность GET. 
Запросы GET нужны для передачи данных от сервера клиенту.
Запросы PUT нужны для отправки данных клиента серверу.

В этом смысле **PUT предназначен для полной замены ресурса, а не для его изменения.** Напротив, **целью PATCH является исправление или частичное изменение ресурса**.

Например, мы решили организовать возможность изменения адреса в заказе. Один из способов реализовать это в REST API - использовать PUT:
```java
@PutMapping(path="/{orderId}",
		   consumes"application/json)
public TacoOrder putOrder(
	@PathVariable("orderId") Long orderId,
	@RequestBody TacoOrder order) {
	order.setId(orderId);
	return repo.save(orderId);
}
```
Это вполне работоспособное решение, но оно требует, чтобы клиент передал в запросе PUT все данные о заказе. Семантически PUT означает *поместить все данные по указанному URL*, полностью заменив все имеющиеся данные.

Если какое-либо свойство в запросе отсутсвует, то оно будет затерто нулевым значением. Даже ID рецентов тако в заказе нужно будет указать вместе с остальными данными, иначе они будут удалены из заказа.

**Итак, PUT выполняет ПОЛНУЮ ЗАМЕНУ ресурса. А как можно изменить только часть информации? - Вот для этого и нужены PATCH!**
```java
@PatchMapping(path="/order{id}",
			 consumes="application/json")
public TacoOrder patchOrder(@PathVariable("orderId") Long orderId,
						   @RequestBody TacoOrder patch) {
	TacoOrder order = repo.findById(orderId).get();

	if(patch.getDeliveryStreet() != null) {
		order.setDeliveryStreet(patch.getDeliveryStreet());
	}

	... //пропустил шаблонный код проверок на null и изменения в случае если patch'им

	if(patch.getCcCVV() != null) {
		order.setCcCVV(patch.getCcCVV());
	}
	return repo.save(order);
}
```
Первое на что следует обратить внимание - метод patchOrder() отмечен аннотацией **@PatchRequest**

И еще что patchOrder() немного сложнее метода putOrder().
Хоть аннотации и разные, мы должны писать код, который фактически и определяет синематическую разницу между PUT и PATCH.

putOrder() принимает полный набор данных и просто сохраняет их. Но patchOrder() проверяет, какие данные доступны в запроса (не null). Вместо полной замены заказа новыми данными он применяет только ненулевые значения к существующему заказу.

Такой подход позволяет клиенту отправлять только те свойства, которые следует изменять, а серверу сохранять существующие данные для любых свойств, не указанных клиентом.

![[Cпособы обработки PATCH.png]]
__
### Zero-Links
- [[Создание контроллеров RESTful]]

__
### Links
- 

