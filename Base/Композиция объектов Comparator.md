2022-09-2109:50
Tags: #Java #JavaCoreAdvanced 

__
# Композиция объектов Comparator
Статический метод Comparator.comparing можно использовать, чтобы вернуть Comparator, основанный на объекте Function, извлекающем ключ сравнения:
```java
//соритровка яблок по ВОЗРАСТАНИЮ
Comparator<Apple> c = Comparator.comparing(Apple::getWeight); 
```

Для того, чтобы отсортировать объекты не по умолчанию (по возрастанию), а по убыванию, для этого не нужно создавать отдельный экземпляр интерфейса Comparator. В данном интерфейсе существует метод с реализацией по умолчанию *reserved*, который меняет порядок сортировки заданного компаратора на обратный. Для сортировки яблок по убыванию нужно модифицировать предыдущий пример:
```java
//соритровка яблок по УБЫВАНИЮ
inventory.sort(comparing(Apple::getWeight).reserved());
```

## Организация объектов Comparator с цепочкой

Что будет, если попадутся два яблока с одинаковым весом? Какое из них должно идти первым? Имеет смысл добавить второй объект Comparator для дальнейшего уточнения сравнения. Например, после сравнения двух яблок по весу можно сравнить их по стране происхождения. Сделать это можно с помощью метода *thenComparing*. Он принимает функцию в качестве параметра (подобно методу *сomparing*), позволяя указать второй объект Comparator на случай, если два объекта исходного Comparator были сочтены равными. 
```java
inventory.sort(comparing(Apple::getWeight)
		 .reserved())
		 .thenComparing(Apple::getCountry));
```
__
### Zero-Links
- [[Композиция]]



