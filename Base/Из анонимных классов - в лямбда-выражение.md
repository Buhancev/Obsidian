2022-10-2220:52
Tags: #Java #JavaCoreAdvanced 
__
# Из анонимных классов - в лямбда-выражение

Первый простой рефакторинг, который необходимо выполнить: преобразовать анонимные классы, где реализован один-единственный абстрактный метод, в лямбда-выражение. Почему? Анонимные классы подвержены ошибкам и не отличаются компактностью. Лямда-выражения также обеспечивают более лаконичный и читабельный код.

Анонимный класс для создания объекта типа Runnable
```java
Runnable r1 = new Runnable() {
	public void run(){
		System.out.println("hello");
	}
};
```
и его аналог с лямда-выражение
```java
Runnable r2 = () -> System.out.println("hello");
```

Но в определенных случаях преобразование анонимных классов в лямбда-выражения может оказаться непростой задачей.
- Во-первых, смысл ключевых слов this и super различен для анонимных классов и лямбда-выражений. Внутри анонимного класса this ссылается на сам анонимный класс, а внутри лямбда-выражения - на охватывающий его класс.
- Во-вторых, анонимные классы могут затенять переменные из охватывающего класса. Лямбда-выраженя - нет, как показано ниже
```java
int a = 10;

Runnable r1 = new Runnable() {
	public void run(){
	//все в порядке!
		int a = 2;
		System.out.println(a);
	}
};

Runnable r2 = () -> {
	int a = 2; // ошибка компиляции!
	System.out.println("hello");
};
```

Наконец, преобразование анонимного класса в лямбда-выражении может привести к неоднозначности кода в случае перезагрузки. И действительно, тип анонимного класса задается явным образом при создании экземпляра, а тип лямба-выражения зависит от контекста.

Пусть мы объявили функциональный интерфейс Task с такой же сигнатурой, как у Runnable
```java
interface Task {
	void execute();
}

public static void doSmht(Runnable r) {r.run();}
public static void doSmht(Task a) {a.execute(); }
```

Передать анонимный класс, реализующий интерфейс Task, можно без всяких проблем
```java
doSmth(new Task() {
	public void execute() {
		System.out.println("Danger!");
	}
});
```

А преобразование этого анонимного класса в лямбда-выражение приведет к неоднозначности вызова метода, поскольку подходящим целевым типом будет и Runnable, и Task
```java
doSmth( () -> System.out.println("Danger!"));
//Проблема: подходит как для doSmht(Runnable), так и для doSmht(Task)
```
Решить эту проблему можно явным преобразованием типа (Task)
```java
doSmth( (Task) () -> System.out.println("Danger!"));
```

Но! Большинство IDE поддерживают подобный рефакторинг и автоматически исключают возникновение таких проблем.

__
### Zero-Links
- [[00 Рефакторинг, тестирование и отладка]]

__
### Links
- 

