2022-09-2216:17
Tags: #Java #JavaCoreAdvanced #StreamAPI 
__
# Отображение
Распространная идиома обработки данных - выбор информации из определенных объектов. Например, на языке SQL можно выбрать из таблицы конкретный столбец.
StreamAPI предоставляет схожие возможности посредством map и flatMap.

#### Применение функции к каждому из элементов потока данных
Потоки данных поддерживают метод *map*, принимающий в качестве аргумента функцию. Эта функция затем применяется к каждому из элементов потока данных, отображая его на новый элемент. (Это называется термином *отображение*(mapping), потому что он синонимичен термину *преобразование*(transforming), но с дополнительными оттектом смысла "создания новой версии", а не просто "модификации").

Например, код ниже извлекает названия блюд из потока данных:
```java
List<String> dishName = menu.stream()
							.map(Dish::getName)
							.collect(toList());
```
Благодаря тому, что метод getName возвращает строку, map возвращает поток данных типа 
```java
Stream<String>
```

Рассмотрим другой пример. Для заданного списка слов необходимо вернуть список с количеством символов в каждом из слов. 
```java
List<String> words = Arrays.asList("Modern", "Java", "In", "Action");
List<Integer> wordLenghts = words.stream()
								 .map(String::lenght)
								 .collect(toList());
```

Вернемся к примеру с извлечением названий блюд. Что, если нужно узнать длину названия каждого блюда? Для этого достаточно добавить в цепочку вызовов еще один вызов map:
```java
List<Integer> dishNameLenghts = menu.stream()
									.map(Dish::getName)
									.map(String::lenght)
									.collect(toList());
```

# Cхлопывание потоков данных
Мы увидели, как получить длину каждого из слов в списке с помощью метода *map*/ Немного обобщим идею и попробуем вернуть список всех *уникальных* символов, содержащихся в списке этих слов. Например, при заданных словах ["Hello", "World"], должен вернуться список ["H", "e", "l", "o", "w", "r", "d"].

Может показаться, что это несложная задача и достаточно отобразить каждое из слов в список символов, после чего вызвать *distinct* для фильтрации дубликатов:
```java
words.stream()
	 .map(word -> word.split(""))
	 .distinct()
	 .collect(toList());
```
Проблема с этим подходом в том, что передаваемое в метод *map* лямбда-выражение возвращает массив String(строк) для каждого из слов. Метод *map* возвращает в поток данных типа:
```java
Stream<String[]>
А нам нужен
Stream<String>, отражающий поток символов
```
![[Неправильно использование метода map для получения уникальных символов из списка слов.png]]

#### К счастью ! Эту проблему можно решить с помощью метода *flatMap*.
Попробуем воспользоваться метода map и Array.stream.
Во-первых, нам понадобиться поток символов вместо потока массивов. Существует метод Arrays.stream(), принимающий на вход массив и возвращающий поток данных:
```java
String[] arraysOfWords = {"Goodbye", "World"};
Stream<String> streamOfwords = Arrats.stream(arraysOfWords);
```
Включим его в предыдущий конвейер и посмотрим, что получится:
```java
words.stream()
	 .map(word -> word.split("")) //превращает каждое слово в массив букв
	 .map(Arrays::stream) //превращает каждый массив букв в отдельный поток
	 .distinct
	 .collect(toList());
```
Полученное решение не работает! Дела в том, что мы получили список поток
```java
точнее List<Stream<String>>
```
И действительно, мы преобразовали каждое из слов в массив его букв, а затем из каждого массива букв отдельный поток.

## Метод flatMap
Решить указанную проблему можно с помощью метода *flatMap* следующим образом:
```java
List<String> uniqueCharacters = words.stream()
									 .map(word -> word.split(""))
									 .flatMap(Arrays::stream)/*схлопывает все
									 сгенерированные потоки данных в единый*/
									 .distinct()
									 .collect(toList());
```
При использовании метода *flatMap* каждый из массивов отображается не в отдельный поток данных, а в *содержимое единного потока*. Все потоки, генерируемые при использовании map(Arrays::stream), cливаются (схлопываются) в единый поток. Последствия применения метода *flatMap* показаны на рисунке ниже.
![[Использование метода flatMap для получения уникальных символов из списка слов.png]]
В двух словах, метод *flatMap* дает возможность заменить каждое значение потока другиv поток, после чего конкатенировать все полученные потоки в один.
__
### Zero-Links
- [[Потоковые операции]]
- [[Промежуточные операции]]

__
### Links
- [[Отображение в числовой поток данных]]

