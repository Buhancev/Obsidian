2022-10-2115:13
Tags: #Java #JavaCoreAdvanced #CollectionAPI 

__
# Паттерны вычисления
Иногда требуется выполнить (или не выполнить) операцию и сохранить её результат в зависимости от того, если ли ключ в ассициативном массива.
Есть три операции
- computeIfAbsent - если для ключа значение не задано (ключ отсутсвуте или значение у него null), то вычисляется новое значение для этого ключа и добавляется в ассоциативный массив
- computeIfPresent - если ключ присутсвует, вычисляется значение для него и добавляется в ассоциативный массив
- compute - операция вычисляет и добавляется значение для заданного ключа в ассоциативном массиве.

Метод computeIfAbsent, в частности, применяется для кеширования информации. Допустим, выполняем синтаксический разбор каждой из строк файлов и вычисляем их SHA-256-хеши. Если данные уже были обработаны, то не нужно вычислять занаво.
Теперь предположим, что кеш реализован на основе ассоциативного массива, а для вычисления хешей используется экземпляр класса MessageDigest
```java
Map<String, byte[]> dataToHash = new HashMap<>();
MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");

lines.forEach(line -> 
			dataToHash.computeIfAbsent(
				line, //line представляет искомый ключ
				this::calculateDigest)); //операция выполняется, если не найдено
										//ни одного ключа

private byte[] calculateDigest(String key) {
	return messageDigest.digest(key.getBytes(StandartCharset.UTF_8));
	//вспомогательная функция вычисления хеша заданного ключа
}
```

Способ также удобен для работы с ассоциативными массивами, хранящими несколько значений для одного ключа. При необходимости добавить элемент в Map(K, List(V)), нужно обеспечить инициализацию записи. Потребуется написать немалый объем кода. 

Допустим, формируем список фильмов для друга Рафаэля
```java
String friend = "Raphael";

List<String> movies = friendsToMovieds.get(friend); 
//проверяем, что список инициализирован 
if(movies = null) {
	movies = new ArrayList<>();
	friendsToMovieds.put(friend, movies);
}
movies.add("Star Wars");
System.out.println(friendsToMovieds); //{Raphael:[Star Wars]}
```
Вместо такого ужасного кода можно использовать метод computeIfAbsent. Если ключ не найдет, то метод добавляет вычисленное значение в ассоциативный массив и возвращает его; в противном случае возвращается уже имеющееся значение.
```java
friendsToMovieds.computeIfAbsent("Raphael", name -> new ArrayList<>())
	.add("Star War");
```
Метод computeIfAbsent вычисляет новое значение, если соответствующее ключу текущее значение присутсвуте в ассоциативном массиве и не равно null. Обратите внимаение на небольшой нюанс; если вычисляющая значение функция вернет null, то текущее соответсвующее ключа/значения удаляется из ассоциативного массива. 
__
### Zero-Links
- [[Работа с ассоциативными массивами]]

__
### Links
- 

