2022-10-1516:48
Tags: #Java #JavaCoreAdvanced #StreamAPI 

__
# Превращаем последовательный поток данных в параллельный

Огранизовать параллельное выполнение вышеприведенного функционального процесса свертки (суммирования) можно путем преобразования поока данных в параллельный. 

Вызовем метод parallel
```java
public static long parallelSum(long n) {  
    return Stream.iterate(1L, i -> i + 1)  
            .limit(n)  
            .parallel() //превращаем поток в параллельный
            .reduce(0L, Long::sum);  
}
```
"Под капотом" после вызова parallel поток данных делится на несколько порций, как показано на рисунке ниже. Операция свертки объединяет все значения полученные результаты частных сверток каждого из потоков.
![[Параллельная операция свертки.png]]

На практике, вызов parallel
На практике, вызов parallel для последовательного потока не означает какого-либо конкретного преобразования самого потока. "Под капотом" просто происходит установка булевого флага, который указывает, что все следующие за операции следует выполнять параллельно.

Аналогично можно преобразовать параллельный поток данных в последовательный, вызвав для этого метод sequential

Может показаться, что с помощью комбинирования этих двух методов можно добиться очень точного контроля над тем, какие операции при обходе потока данных производить параллельно, а какие - последовательно

Например
```java
stream.parallel()
	.filter()
	.sequential()
	.map()
	.parallel()
	.reduce();
```
НО! Приоритет будет всегда у последнего вызова parallel или sequeantial, который влияет на ВЕСЬ конвейер. В этом примере конвейер будет выполняться параллельно, поскольку последним в нем был вызова метод parallel

Проведем тест: итеративный, последовательный и паралелльный
![[бенчмарк итеративный.png]]
![[бенчмарк последовательный.png]]
![[бенчмарк параллельный.png]]
Итеративный в 40 раз быстрее, чем последовательный, а последовательный в 5 раз быстре, чем параллельный!

В чем же дело?
- Метод iterate генерирует упакованные объекты, которые приходится распаковывать в обычные числа, прежде чем складывать
- Операция iterate плохо поддается разбиению на отдельные порции для параллельного выполнения

Особый интерес вызывает второй фактор, ведь нужно не забывать: НЕКОТОРЫЕ потоковые операции лучше поддаются распараллеливанию, чем другие.

Операция iterate плохо поддается распараллеливанию, поскольку следующий результат зависит от предыдущего - операция iterate последовательна
![[операция iterate по своей природе последовательна.png]]

Это значит, что в частном случае процесс сверкти происходит не так, как показано на рисунке параллельной свертки. Так как полный список чисел недоступен в начале свертки, из-за чего невозможно разумным образом разбить поток данных на порции для параллельной обработки. А указывая, что поток данных паралелльный, мы вносим дополнительные накладные расходы в виде распределенния операций суммирования по различным потокам выполнения.

Данный пример показывает, насколько запутанно и порой неочевидно может быть параллельное программирование. При неправильном применении оно может значительно ухудшить общую производительность, так что при вызове "волшедного" метода parallel необходимо четко понимать, что происходит за кулисами

## Более специализированные методы
Как же эффективно использовать возможности многоядерных процессоров? 
Ранее обсуждался метод LongStream.rangeClosed. У него есть два преимущества по сравнению с iterate
- Работает непосредственно с простым типом long, что не требует дополнительных расходов на упаковку и распаковку
- Генерирует диапазоны целых чисел, легко разбиваемые на отдельные потоки. Например диапазон 1-20 можно легко разбить на порции 1-5, 6-10, 11-15, 16-20.

Взглянем на производительности.
```java
public long rangedSum(int N) {
	return LongStream.rangeClosed(1, N)
		.reduce(0L, Long::sum);
}
```
![[бенчмарк последовательного rangeClosed.png]]
Он отработал быстрее, чем вариант последовального обхода с iterate, так как не было расходов на упаковку распаковку.

Что же будет при параллельной версии?
```java
public long rangedSum(int N) {
	return LongStream.rangeClosed(1, N)
		.parallel()
		.reduce(0L, Long::sum);
}
```
![[бенчмарк rangeClosed параллельный.png]]
Наконец-то свертка работает быстрее! Теперь операция работает как на рисунке при параллельной свертки. Стоит так же отметить, что параллельная версия работает примерно на 20% быстрее исходной итеративной версии, так что при должном применении функциональный стиль программирования упрозает использование параллелизма совеременных многоядерных компьюетров, по сравнению с императивным.

Тем не менее, нужно помнить, что распараллеливание имеет свою цену. 
- рекурсивно разбивается поток данных
- распределение операции свертки по различным потокам
- последующее объединение этих операций в единое значение
Но! Перемещение данных между различными ядрами процессора требует куда больше ресурсов, чем можно предположить, так что выполняемые параллельно на другом ядре вычисления должны занимать больше времени, чем перемещение данных с одного ядра на другое.

Вообще говоря, во многих сценариях невозможно или не имеет смысла задействовать параллелизм. Прежде чем воспользоваться им, нужно убедиться в правильности логики. Нет смысла в быстром получении результатов, если они неправильны.

__
### Zero-Links
- [[Параллельные потоки данных]]
- [[Правильное применение параллельных потоков данных]]
__
### Links
- 

