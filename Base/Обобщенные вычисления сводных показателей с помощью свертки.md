2022-10-0222:18
Tags: #Java #JavaCoreAdvanced #StreamAPI 

__
# Обобщенные вычисления сводных показателей с помощью свертки
Все обсуждавшиеся выше коллекторы, по существу, предсталвяют собой лишь удобные специализированные варианты процесса свертки, задаваемого с помощью фабричного метода reducing. 

Фабричный метод Collectors.reducing - обобщение всех ранее упоминавшихся. Можно сказать, обсуждавшиеся ранее частные случаи существуют лишь для удобства программистов (удобство и удобочитаемость важны!)

Например, вычислить суммарное число калорий в меню можно с помощью коллектора, созданного на основе метода reducing
```java
int totalCalories = menu.stream()
	.collect(reducing(
		0, Dish::getCalories, (i, j) -> i + j));
```
Он принимает три аргумента
- Первый - начальное значение для операции свертки, а равно и значение, возвращаемое при отсутсвии элементов в потоке.
- Второй - та же функция, с помощью которой мы преобразовывали блюдо в значение типа int, cоотвествующее количеству содержащихся в нем калорий.
- Третий - BinaryOperator, который агрегирует два элемента в одно значение того же типа. 


Аналогично, можно найти самое калорийное блюдо с помощью одногоаргументой версии метода reducing
```java
Optional<Dish> mostCaloriesDish = 
	menu.stream()
		.collect(reducing(
			(d1, d2) -> d1.getCalories() > d2.getCalories() ? d1 : d2));
```
Этот метод можно рассматривать как частный случай трехаргументой версии, с первым элементом потока данных в качестве *начального значения и тождественной функции*(которая возвращает аргумент в незименно виде) в качестве функции преобразования. Это также означает, что при передачи методу collect пустого потока у коллектора reducing с одном аргументом не окажется никакого начально значения, поэтому он вернет объект Optional(Dish)
![[Разница метода collect и reduce.png]]

## Гибкость фреймворка коллекций: выполнение одних операций разными способами

Еще более упростить пример суммирования с коллектором reducing можно, воспользовавшись ссылкой на метод Integer::sum
```java
int totalCalories = menu.stream()
	.collect(reducing(
		0, Dish::getCalories, Integer::sum);
```
![[Схема вычисления сумморного числа калорий меню с использованием процесса свертки.png]]


Коллектор counting, упоминавшийся ранее, в действительности реализуется аналогично с помощью фабричного метода reducing с тремя аргументами. Он преобразует каждый из элементов потока в объек типа Long со значнием 1, после чего их суммирует. Он реализован так
```java
public static <T> Collector<T, ?, Long> counting(){
	return reducing(0L, e -> 1L, Long::sum);
}
```
### Джокерный символ обобщенных классов (?)
В прошлом примере был символ (?) в качестве второго обобщенного типа в сигнатуре возвращаемого фабричным методом counting коллектора. Наверное, вы уже знакомы с такой нотацией, особенно если часто используете фреймворк коллекций Java. Но в данном случае он означает лишь то, что тип накопителя коллектора неизвестен или (что эквивалентно) что сам накопитель может быть любого типа. Мы привели его здесь, чтобы в точности отразить сигнатуру метода в том виде, в каком она описана в классе Collectors.

Ту же операция можно выполнить и без коллектора - путем отображения потока блюд в число калорий каждого блюда путем послелующей сверткой получившегося потока данных, применяя ту же ссылку на метод
```java
int totalCalories = menu.stream()
	.map(Dish::getCalories)
	.reduce(Integer::sum).get();
```
Отмечу, что для вызов для потока данных операции reduce(Integer::sum), как и любой другой одноаргументной операции, возвращает не int, а Optional(Integer) для безопасной свертки пустого потока. В этом случае мы извлекаем значение из объекта Optional с помощью метода get. Обратим внимание, что можно без опаски использовать метод get лишь потому что уверены - поток не пуст. В общем безопаснее было бы распаковать содержащееся в Optional значение с помощью метода, который позволял бы задавать значние по умолчания, например orElse и orElseGet. Наконец, можно получить тот же результат с помощью еще более лаконичного кода, отобразив поток данных в IntStream и вызвав метод для него метод sum
```java
int totalCalories = menu.stream()
	.mapToInt(Dish::getCalories)
	.sum();
```

## Выбор оптимального решения для конкретной ситуации
И снова видно, что можно решать одну задачу различными способами. Этот пример также демонстрирует, что коллекторы, хотя они и сложнее в использовании, чем непосредственно методы интерфейса Stream, обеспечивают более высокий уровень абстракции и обобщеия, их проще переиспользовать и адаптировать к конкретной задачи.

Рекомендуется выбирать наиболее специализированное и в то же время достаточно общее решение. Зачастую оно будет более удобочитаемым и прозводительным.

Например, для вычисления суммарного числа калорий в меню лучше выбрать последнее решение с IntStream, ведь благодаря потоку IntStream не нужны все опервции автораспакови.


__
### Zero-Links
- [[Свертка и вычисление сводных показателей]]

__
### Links
- 

